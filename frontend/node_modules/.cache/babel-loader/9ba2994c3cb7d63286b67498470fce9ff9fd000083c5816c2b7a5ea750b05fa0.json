{"ast":null,"code":"/**\r\n * ThingSpeak API Service\r\n * Handles fetching data from ThingSpeak channels\r\n */\n\nconst DEFAULT_READ_API_KEY = \"MWFBV98HOZOHTHY4\";\nconst BASE_URL = \"https://api.thingspeak.com/channels\";\n\n/**\r\n * Fetches the latest data from a ThingSpeak channel\r\n */\nexport const fetchLatestData = async (channelId, apiKey = DEFAULT_READ_API_KEY, results = 1) => {\n  if (!channelId) {\n    throw new Error('Channel ID is required');\n  }\n  try {\n    const url = `${BASE_URL}/${channelId}/feeds.json?api_key=${apiKey}&results=${results}`;\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`ThingSpeak API error: ${response.status}`);\n    }\n    const data = await response.json();\n    if (!data || !data.feeds || data.feeds.length === 0) {\n      throw new Error('No data available from ThingSpeak');\n    }\n    return data;\n  } catch (error) {\n    console.error('Error fetching data from ThingSpeak:', error);\n    throw error;\n  }\n};\n\n// Time-based fetching with timestamp handling to avoid duplicates\nexport const fetchDataSinceLastUpdate = async (channelId, lastTimestamp, apiKey = DEFAULT_READ_API_KEY) => {\n  if (!channelId) {\n    throw new Error('Channel ID is required');\n  }\n  try {\n    // If lastTimestamp is provided, fetch data after that timestamp\n    const timestampParam = lastTimestamp ? `&start=${lastTimestamp}` : '';\n    const url = `${BASE_URL}/${channelId}/feeds.json?api_key=${apiKey}${timestampParam}`;\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`ThingSpeak API error: ${response.status}`);\n    }\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Error fetching data from ThingSpeak since last update:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Calculate blood pressure from PTT\r\n * @param {Array} ecgSamples - Array of ECG samples\r\n * @param {number} spo2 - SpO2 value\r\n * @returns {Object} - Systolic and diastolic BP\r\n */\nconst calculateBP = (ecgSamples, spo2) => {\n  // Assuming 1000Hz sampling rate (1 sample = 1ms)\n  const PTT = 0.1; // 100ms - simplified assumption\n\n  // BP estimation formulas\n  const systolic = 150 - 100 * PTT;\n  const diastolic = 100 - 60 * PTT;\n  return {\n    systolic: Math.round(systolic),\n    diastolic: Math.round(diastolic)\n  };\n};\n\n/**\r\n * Maps the raw ThingSpeak data to patient vital signs\r\n * Field mapping:\r\n * field1: Temperature (°C)\r\n * field2: Emergency Alert Level (0: Normal, 1: Moderate Risk, 2: High Risk)\r\n * field3: Heart Rate (BPM)\r\n * field4: SpO2 (%)\r\n * field5: Latitude\r\n * field6: Longitude\r\n * field7: Avg ECG\r\n * field8: ECG Sample Array\r\n */\nexport const mapThingSpeakToPatientVitals = data => {\n  if (!data || !data.feeds || data.feeds.length === 0) {\n    return null;\n  }\n  const latestEntry = data.feeds[0];\n\n  // Convert string values to numbers\n  const temperature = parseFloat(latestEntry.field1);\n  const alertLevel = parseInt(latestEntry.field2);\n  const heartRate = parseFloat(latestEntry.field3);\n  const spo2 = parseFloat(latestEntry.field4);\n  const latitude = parseFloat(latestEntry.field5);\n  const longitude = parseFloat(latestEntry.field6);\n  const avgEcg = parseFloat(latestEntry.field7);\n  const ecgSamples = JSON.parse(latestEntry.field8);\n\n  // Calculate BP from ECG samples and SpO2\n  const bp = calculateBP(ecgSamples, spo2);\n  return {\n    vitals: {\n      temperature: isNaN(temperature) ? \"--\" : temperature.toFixed(1),\n      alertLevel: isNaN(alertLevel) ? 0 : alertLevel,\n      heartRate: isNaN(heartRate) ? \"--\" : Math.round(heartRate),\n      spo2: isNaN(spo2) ? \"--\" : Math.round(spo2),\n      avgEcg: isNaN(avgEcg) ? \"--\" : avgEcg,\n      ecgSamples: Array.isArray(ecgSamples) ? ecgSamples : [],\n      bp: bp\n    },\n    location: {\n      lat: isNaN(latitude) ? null : latitude,\n      lng: isNaN(longitude) ? null : longitude,\n      accuracy: 15\n    },\n    status: {\n      temperature: temperature > 37.8 ? \"Elevated\" : temperature < 35.5 ? \"Low\" : \"Normal\",\n      heartRate: heartRate > 100 ? \"Elevated\" : heartRate < 60 ? \"Low\" : \"Normal\",\n      spo2: spo2 < 95 ? \"Low\" : \"Normal\",\n      bp: bp.systolic > 140 || bp.diastolic > 90 ? \"Elevated\" : bp.systolic < 90 || bp.diastolic < 60 ? \"Low\" : \"Normal\",\n      alert: alertLevel === 0 ? \"Normal\" : alertLevel === 1 ? \"Moderate Risk\" : \"High Risk\"\n    },\n    lastUpdated: new Date(latestEntry.created_at).toLocaleString()\n  };\n};\n\n/**\r\n * Fetches and formats patient vitals from ThingSpeak\r\n */\nexport const getPatientVitals = async channelId => {\n  if (!channelId) {\n    throw new Error('Channel ID is required');\n  }\n  try {\n    const data = await fetchLatestData(channelId);\n    const vitals = mapThingSpeakToPatientVitals(data);\n    if (!vitals) {\n      throw new Error('Failed to map ThingSpeak data to vitals');\n    }\n    return vitals;\n  } catch (error) {\n    console.error('Error getting patient vitals:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Converts ThingSpeak data to CSV format\r\n * @param {Object} data - ThingSpeak data object\r\n * @returns {String} - CSV formatted string\r\n */\nexport const convertThingSpeakDataToCSV = data => {\n  if (!data || !data.feeds || data.feeds.length === 0) {\n    return null;\n  }\n\n  // Create CSV header\n  const headers = ['timestamp', 'temperature', 'alertLevel', 'heartRate', 'spo2', 'latitude', 'longitude', 'avgEcg', 'systolicBP', 'diastolicBP'];\n\n  // Create CSV content\n  const csvRows = [];\n  csvRows.push(headers.join(','));\n\n  // Process each feed entry\n  data.feeds.forEach(feed => {\n    const temperature = parseFloat(feed.field1);\n    const alertLevel = parseInt(feed.field2);\n    const heartRate = parseFloat(feed.field3);\n    const spo2 = parseFloat(feed.field4);\n    const latitude = parseFloat(feed.field5);\n    const longitude = parseFloat(feed.field6);\n    const avgEcg = parseFloat(feed.field7);\n    const ecgSamples = feed.field8 ? JSON.parse(feed.field8) : [];\n\n    // Calculate BP\n    const bp = calculateBP(ecgSamples, spo2);\n    const row = [new Date(feed.created_at).toISOString(), isNaN(temperature) ? \"\" : temperature.toFixed(1), isNaN(alertLevel) ? \"\" : alertLevel, isNaN(heartRate) ? \"\" : Math.round(heartRate), isNaN(spo2) ? \"\" : Math.round(spo2), isNaN(latitude) ? \"\" : latitude, isNaN(longitude) ? \"\" : longitude, isNaN(avgEcg) ? \"\" : avgEcg, bp.systolic, bp.diastolic];\n    csvRows.push(row.join(','));\n  });\n  return csvRows.join('\\n');\n};\n\n/**\r\n * Downloads ThingSpeak data as a CSV file\r\n * @param {String} channelId - ThingSpeak channel ID\r\n * @param {String} filename - Name for the CSV file\r\n * @param {Number} days - Number of days of data to fetch (default: 7)\r\n */\nexport const downloadThingSpeakDataAsCSV = async (channelId, filename = 'patient_data.csv', days = 7) => {\n  if (!channelId) {\n    throw new Error('Channel ID is required');\n  }\n  try {\n    // Calculate start date (days ago from now)\n    const startDate = new Date();\n    startDate.setDate(startDate.getDate() - days);\n\n    // Fetch data for the specified period\n    const url = `${BASE_URL}/${channelId}/feeds.json?api_key=${DEFAULT_READ_API_KEY}&start=${startDate.toISOString()}`;\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`ThingSpeak API error: ${response.status}`);\n    }\n    const data = await response.json();\n\n    // Convert data to CSV\n    const csvContent = convertThingSpeakDataToCSV(data);\n    if (!csvContent) {\n      throw new Error('No data available to download');\n    }\n\n    // Create and download the CSV file\n    const blob = new Blob([csvContent], {\n      type: 'text/csv;charset=utf-8;'\n    });\n    const link = document.createElement('a');\n    const urlObject = URL.createObjectURL(blob);\n    link.setAttribute('href', urlObject);\n    link.setAttribute('download', filename);\n    link.style.visibility = 'hidden';\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    return true;\n  } catch (error) {\n    console.error('Error downloading ThingSpeak data as CSV:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Starts continuous data logging from ThingSpeak to localStorage\r\n * @param {String} channelId - ThingSpeak channel ID\r\n * @param {Number} intervalMinutes - Fetch interval in minutes\r\n * @returns {Object} - Controller object with start/stop methods\r\n */\nexport const startContinuousDataLogging = (channelId, intervalMinutes = 5) => {\n  if (!channelId) {\n    throw new Error('Channel ID is required');\n  }\n  let intervalId = null;\n  let isLogging = false;\n  let lastTimestamp = null;\n  const storageKey = `thingspeak_data_${channelId}`;\n\n  // Initialize from localStorage if exists\n  const initFromStorage = () => {\n    const storedData = localStorage.getItem(storageKey);\n    if (storedData) {\n      try {\n        const parsedData = JSON.parse(storedData);\n        if (parsedData.feeds && parsedData.feeds.length > 0) {\n          // Get the latest timestamp\n          const latestEntry = parsedData.feeds[parsedData.feeds.length - 1];\n          lastTimestamp = new Date(latestEntry.created_at).toISOString();\n        }\n      } catch (error) {\n        console.error('Error parsing stored data:', error);\n        localStorage.removeItem(storageKey);\n      }\n    }\n  };\n\n  // Fetch and store new data\n  const fetchAndStore = async () => {\n    try {\n      const data = await fetchDataSinceLastUpdate(channelId, lastTimestamp);\n      if (data && data.feeds && data.feeds.length > 0) {\n        // Update lastTimestamp to the latest entry\n        const latestEntry = data.feeds[data.feeds.length - 1];\n        lastTimestamp = new Date(latestEntry.created_at).toISOString();\n\n        // Merge with existing data\n        const storedData = localStorage.getItem(storageKey);\n        let mergedData;\n        if (storedData) {\n          const parsedData = JSON.parse(storedData);\n          mergedData = {\n            ...data,\n            feeds: [...parsedData.feeds, ...data.feeds]\n          };\n        } else {\n          mergedData = data;\n        }\n\n        // Store in localStorage\n        localStorage.setItem(storageKey, JSON.stringify(mergedData));\n\n        // Also trigger CSV download if the dataset is getting large\n        if (mergedData.feeds.length > 1000) {\n          const csvContent = convertThingSpeakDataToCSV(mergedData);\n          const blob = new Blob([csvContent], {\n            type: 'text/csv;charset=utf-8;'\n          });\n          const link = document.createElement('a');\n          const urlObject = URL.createObjectURL(blob);\n          link.setAttribute('href', urlObject);\n          link.setAttribute('download', `patient_data_${channelId}_${new Date().toISOString().slice(0, 10)}.csv`);\n          link.style.visibility = 'hidden';\n          document.body.appendChild(link);\n          link.click();\n          document.body.removeChild(link);\n\n          // Reset storage after download\n          localStorage.setItem(storageKey, JSON.stringify({\n            ...data,\n            feeds: data.feeds\n          }));\n        }\n      }\n    } catch (error) {\n      console.error('Error in continuous data logging:', error);\n    }\n  };\n\n  // Start logging\n  const start = () => {\n    if (isLogging) return;\n    initFromStorage();\n    fetchAndStore(); // Immediate first fetch\n\n    // Set up interval (convert minutes to milliseconds)\n    intervalId = setInterval(fetchAndStore, intervalMinutes * 60 * 1000);\n    isLogging = true;\n    console.log(`Started continuous data logging for channel ${channelId} every ${intervalMinutes} minutes`);\n    return true;\n  };\n\n  // Stop logging\n  const stop = () => {\n    if (!isLogging) return;\n    clearInterval(intervalId);\n    intervalId = null;\n    isLogging = false;\n    console.log(`Stopped continuous data logging for channel ${channelId}`);\n    return true;\n  };\n\n  // Export data as CSV\n  const exportToCSV = (filename = `patient_data_${channelId}.csv`) => {\n    const storedData = localStorage.getItem(storageKey);\n    if (!storedData) {\n      console.warn('No data available to export');\n      return false;\n    }\n    try {\n      const parsedData = JSON.parse(storedData);\n      const csvContent = convertThingSpeakDataToCSV(parsedData);\n      const blob = new Blob([csvContent], {\n        type: 'text/csv;charset=utf-8;'\n      });\n      const link = document.createElement('a');\n      const urlObject = URL.createObjectURL(blob);\n      link.setAttribute('href', urlObject);\n      link.setAttribute('download', filename);\n      link.style.visibility = 'hidden';\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      return true;\n    } catch (error) {\n      console.error('Error exporting data to CSV:', error);\n      return false;\n    }\n  };\n\n  // Return controller object\n  return {\n    start,\n    stop,\n    exportToCSV,\n    isLogging: () => isLogging,\n    getStoredData: () => {\n      const storedData = localStorage.getItem(storageKey);\n      return storedData ? JSON.parse(storedData) : null;\n    },\n    clearStoredData: () => {\n      localStorage.removeItem(storageKey);\n      lastTimestamp = null;\n      return true;\n    }\n  };\n};\nexport default {\n  fetchLatestData,\n  mapThingSpeakToPatientVitals,\n  getPatientVitals,\n  downloadThingSpeakDataAsCSV,\n  startContinuousDataLogging,\n  convertThingSpeakDataToCSV\n};","map":{"version":3,"names":["DEFAULT_READ_API_KEY","BASE_URL","fetchLatestData","channelId","apiKey","results","Error","url","response","fetch","ok","status","data","json","feeds","length","error","console","fetchDataSinceLastUpdate","lastTimestamp","timestampParam","calculateBP","ecgSamples","spo2","PTT","systolic","diastolic","Math","round","mapThingSpeakToPatientVitals","latestEntry","temperature","parseFloat","field1","alertLevel","parseInt","field2","heartRate","field3","field4","latitude","field5","longitude","field6","avgEcg","field7","JSON","parse","field8","bp","vitals","isNaN","toFixed","Array","isArray","location","lat","lng","accuracy","alert","lastUpdated","Date","created_at","toLocaleString","getPatientVitals","convertThingSpeakDataToCSV","headers","csvRows","push","join","forEach","feed","row","toISOString","downloadThingSpeakDataAsCSV","filename","days","startDate","setDate","getDate","csvContent","blob","Blob","type","link","document","createElement","urlObject","URL","createObjectURL","setAttribute","style","visibility","body","appendChild","click","removeChild","startContinuousDataLogging","intervalMinutes","intervalId","isLogging","storageKey","initFromStorage","storedData","localStorage","getItem","parsedData","removeItem","fetchAndStore","mergedData","setItem","stringify","slice","start","setInterval","log","stop","clearInterval","exportToCSV","warn","getStoredData","clearStoredData"],"sources":["C:/Users/SAMARTH/OneDrive/Desktop/iot 3/IoT-Main/frontend/src/services/ThingSpeakService.js"],"sourcesContent":["/**\r\n * ThingSpeak API Service\r\n * Handles fetching data from ThingSpeak channels\r\n */\r\n\r\nconst DEFAULT_READ_API_KEY = \"MWFBV98HOZOHTHY4\";\r\nconst BASE_URL = \"https://api.thingspeak.com/channels\";\r\n\r\n/**\r\n * Fetches the latest data from a ThingSpeak channel\r\n */\r\nexport const fetchLatestData = async (channelId, apiKey = DEFAULT_READ_API_KEY, results = 1) => {\r\n  if (!channelId) {\r\n    throw new Error('Channel ID is required');\r\n  }\r\n\r\n  try {\r\n    const url = `${BASE_URL}/${channelId}/feeds.json?api_key=${apiKey}&results=${results}`;\r\n    const response = await fetch(url);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`ThingSpeak API error: ${response.status}`);\r\n    }\r\n    \r\n    const data = await response.json();\r\n    \r\n    if (!data || !data.feeds || data.feeds.length === 0) {\r\n      throw new Error('No data available from ThingSpeak');\r\n    }\r\n    \r\n    return data;\r\n  } catch (error) {\r\n    console.error('Error fetching data from ThingSpeak:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Time-based fetching with timestamp handling to avoid duplicates\r\nexport const fetchDataSinceLastUpdate = async (channelId, lastTimestamp, apiKey = DEFAULT_READ_API_KEY) => {\r\n  if (!channelId) {\r\n    throw new Error('Channel ID is required');\r\n  }\r\n\r\n  try {\r\n    // If lastTimestamp is provided, fetch data after that timestamp\r\n    const timestampParam = lastTimestamp ? `&start=${lastTimestamp}` : '';\r\n    const url = `${BASE_URL}/${channelId}/feeds.json?api_key=${apiKey}${timestampParam}`;\r\n    const response = await fetch(url);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`ThingSpeak API error: ${response.status}`);\r\n    }\r\n    \r\n    const data = await response.json();\r\n    return data;\r\n  } catch (error) {\r\n    console.error('Error fetching data from ThingSpeak since last update:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Calculate blood pressure from PTT\r\n * @param {Array} ecgSamples - Array of ECG samples\r\n * @param {number} spo2 - SpO2 value\r\n * @returns {Object} - Systolic and diastolic BP\r\n */\r\nconst calculateBP = (ecgSamples, spo2) => {\r\n  // Assuming 1000Hz sampling rate (1 sample = 1ms)\r\n  const PTT = 0.1; // 100ms - simplified assumption\r\n  \r\n  // BP estimation formulas\r\n  const systolic = 150 - (100 * PTT);\r\n  const diastolic = 100 - (60 * PTT);\r\n  \r\n  return {\r\n    systolic: Math.round(systolic),\r\n    diastolic: Math.round(diastolic)\r\n  };\r\n};\r\n\r\n/**\r\n * Maps the raw ThingSpeak data to patient vital signs\r\n * Field mapping:\r\n * field1: Temperature (°C)\r\n * field2: Emergency Alert Level (0: Normal, 1: Moderate Risk, 2: High Risk)\r\n * field3: Heart Rate (BPM)\r\n * field4: SpO2 (%)\r\n * field5: Latitude\r\n * field6: Longitude\r\n * field7: Avg ECG\r\n * field8: ECG Sample Array\r\n */\r\nexport const mapThingSpeakToPatientVitals = (data) => {\r\n  if (!data || !data.feeds || data.feeds.length === 0) {\r\n    return null;\r\n  }\r\n  \r\n  const latestEntry = data.feeds[0];\r\n  \r\n  // Convert string values to numbers\r\n  const temperature = parseFloat(latestEntry.field1);\r\n  const alertLevel = parseInt(latestEntry.field2);\r\n  const heartRate = parseFloat(latestEntry.field3);\r\n  const spo2 = parseFloat(latestEntry.field4);\r\n  const latitude = parseFloat(latestEntry.field5);\r\n  const longitude = parseFloat(latestEntry.field6);\r\n  const avgEcg = parseFloat(latestEntry.field7);\r\n  const ecgSamples = JSON.parse(latestEntry.field8);\r\n\r\n  // Calculate BP from ECG samples and SpO2\r\n  const bp = calculateBP(ecgSamples, spo2);\r\n\r\n  return {\r\n    vitals: {\r\n      temperature: isNaN(temperature) ? \"--\" : temperature.toFixed(1),\r\n      alertLevel: isNaN(alertLevel) ? 0 : alertLevel,\r\n      heartRate: isNaN(heartRate) ? \"--\" : Math.round(heartRate),\r\n      spo2: isNaN(spo2) ? \"--\" : Math.round(spo2),\r\n      avgEcg: isNaN(avgEcg) ? \"--\" : avgEcg,\r\n      ecgSamples: Array.isArray(ecgSamples) ? ecgSamples : [],\r\n      bp: bp\r\n    },\r\n    location: {\r\n      lat: isNaN(latitude) ? null : latitude,\r\n      lng: isNaN(longitude) ? null : longitude,\r\n      accuracy: 15\r\n    },\r\n    status: {\r\n      temperature: temperature > 37.8 ? \"Elevated\" : temperature < 35.5 ? \"Low\" : \"Normal\",\r\n      heartRate: heartRate > 100 ? \"Elevated\" : heartRate < 60 ? \"Low\" : \"Normal\",\r\n      spo2: spo2 < 95 ? \"Low\" : \"Normal\",\r\n      bp: bp.systolic > 140 || bp.diastolic > 90 ? \"Elevated\" : \r\n          bp.systolic < 90 || bp.diastolic < 60 ? \"Low\" : \"Normal\",\r\n      alert: alertLevel === 0 ? \"Normal\" : alertLevel === 1 ? \"Moderate Risk\" : \"High Risk\"\r\n    },\r\n    lastUpdated: new Date(latestEntry.created_at).toLocaleString()\r\n  };\r\n};\r\n\r\n/**\r\n * Fetches and formats patient vitals from ThingSpeak\r\n */\r\nexport const getPatientVitals = async (channelId) => {\r\n  if (!channelId) {\r\n    throw new Error('Channel ID is required');\r\n  }\r\n\r\n  try {\r\n    const data = await fetchLatestData(channelId);\r\n    const vitals = mapThingSpeakToPatientVitals(data);\r\n    \r\n    if (!vitals) {\r\n      throw new Error('Failed to map ThingSpeak data to vitals');\r\n    }\r\n    \r\n    return vitals;\r\n  } catch (error) {\r\n    console.error('Error getting patient vitals:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Converts ThingSpeak data to CSV format\r\n * @param {Object} data - ThingSpeak data object\r\n * @returns {String} - CSV formatted string\r\n */\r\nexport const convertThingSpeakDataToCSV = (data) => {\r\n  if (!data || !data.feeds || data.feeds.length === 0) {\r\n    return null;\r\n  }\r\n  \r\n  // Create CSV header\r\n  const headers = [\r\n    'timestamp', \r\n    'temperature', \r\n    'alertLevel', \r\n    'heartRate', \r\n    'spo2', \r\n    'latitude', \r\n    'longitude', \r\n    'avgEcg',\r\n    'systolicBP',\r\n    'diastolicBP'\r\n  ];\r\n  \r\n  // Create CSV content\r\n  const csvRows = [];\r\n  csvRows.push(headers.join(','));\r\n  \r\n  // Process each feed entry\r\n  data.feeds.forEach(feed => {\r\n    const temperature = parseFloat(feed.field1);\r\n    const alertLevel = parseInt(feed.field2);\r\n    const heartRate = parseFloat(feed.field3);\r\n    const spo2 = parseFloat(feed.field4);\r\n    const latitude = parseFloat(feed.field5);\r\n    const longitude = parseFloat(feed.field6);\r\n    const avgEcg = parseFloat(feed.field7);\r\n    const ecgSamples = feed.field8 ? JSON.parse(feed.field8) : [];\r\n    \r\n    // Calculate BP\r\n    const bp = calculateBP(ecgSamples, spo2);\r\n    \r\n    const row = [\r\n      new Date(feed.created_at).toISOString(),\r\n      isNaN(temperature) ? \"\" : temperature.toFixed(1),\r\n      isNaN(alertLevel) ? \"\" : alertLevel,\r\n      isNaN(heartRate) ? \"\" : Math.round(heartRate),\r\n      isNaN(spo2) ? \"\" : Math.round(spo2),\r\n      isNaN(latitude) ? \"\" : latitude,\r\n      isNaN(longitude) ? \"\" : longitude,\r\n      isNaN(avgEcg) ? \"\" : avgEcg,\r\n      bp.systolic,\r\n      bp.diastolic\r\n    ];\r\n    \r\n    csvRows.push(row.join(','));\r\n  });\r\n  \r\n  return csvRows.join('\\n');\r\n};\r\n\r\n/**\r\n * Downloads ThingSpeak data as a CSV file\r\n * @param {String} channelId - ThingSpeak channel ID\r\n * @param {String} filename - Name for the CSV file\r\n * @param {Number} days - Number of days of data to fetch (default: 7)\r\n */\r\nexport const downloadThingSpeakDataAsCSV = async (channelId, filename = 'patient_data.csv', days = 7) => {\r\n  if (!channelId) {\r\n    throw new Error('Channel ID is required');\r\n  }\r\n\r\n  try {\r\n    // Calculate start date (days ago from now)\r\n    const startDate = new Date();\r\n    startDate.setDate(startDate.getDate() - days);\r\n    \r\n    // Fetch data for the specified period\r\n    const url = `${BASE_URL}/${channelId}/feeds.json?api_key=${DEFAULT_READ_API_KEY}&start=${startDate.toISOString()}`;\r\n    const response = await fetch(url);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`ThingSpeak API error: ${response.status}`);\r\n    }\r\n    \r\n    const data = await response.json();\r\n    \r\n    // Convert data to CSV\r\n    const csvContent = convertThingSpeakDataToCSV(data);\r\n    \r\n    if (!csvContent) {\r\n      throw new Error('No data available to download');\r\n    }\r\n    \r\n    // Create and download the CSV file\r\n    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\r\n    const link = document.createElement('a');\r\n    const urlObject = URL.createObjectURL(blob);\r\n    \r\n    link.setAttribute('href', urlObject);\r\n    link.setAttribute('download', filename);\r\n    link.style.visibility = 'hidden';\r\n    \r\n    document.body.appendChild(link);\r\n    link.click();\r\n    document.body.removeChild(link);\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error downloading ThingSpeak data as CSV:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Starts continuous data logging from ThingSpeak to localStorage\r\n * @param {String} channelId - ThingSpeak channel ID\r\n * @param {Number} intervalMinutes - Fetch interval in minutes\r\n * @returns {Object} - Controller object with start/stop methods\r\n */\r\nexport const startContinuousDataLogging = (channelId, intervalMinutes = 5) => {\r\n  if (!channelId) {\r\n    throw new Error('Channel ID is required');\r\n  }\r\n  \r\n  let intervalId = null;\r\n  let isLogging = false;\r\n  let lastTimestamp = null;\r\n  const storageKey = `thingspeak_data_${channelId}`;\r\n  \r\n  // Initialize from localStorage if exists\r\n  const initFromStorage = () => {\r\n    const storedData = localStorage.getItem(storageKey);\r\n    if (storedData) {\r\n      try {\r\n        const parsedData = JSON.parse(storedData);\r\n        if (parsedData.feeds && parsedData.feeds.length > 0) {\r\n          // Get the latest timestamp\r\n          const latestEntry = parsedData.feeds[parsedData.feeds.length - 1];\r\n          lastTimestamp = new Date(latestEntry.created_at).toISOString();\r\n        }\r\n      } catch (error) {\r\n        console.error('Error parsing stored data:', error);\r\n        localStorage.removeItem(storageKey);\r\n      }\r\n    }\r\n  };\r\n  \r\n  // Fetch and store new data\r\n  const fetchAndStore = async () => {\r\n    try {\r\n      const data = await fetchDataSinceLastUpdate(channelId, lastTimestamp);\r\n      \r\n      if (data && data.feeds && data.feeds.length > 0) {\r\n        // Update lastTimestamp to the latest entry\r\n        const latestEntry = data.feeds[data.feeds.length - 1];\r\n        lastTimestamp = new Date(latestEntry.created_at).toISOString();\r\n        \r\n        // Merge with existing data\r\n        const storedData = localStorage.getItem(storageKey);\r\n        let mergedData;\r\n        \r\n        if (storedData) {\r\n          const parsedData = JSON.parse(storedData);\r\n          mergedData = {\r\n            ...data,\r\n            feeds: [...parsedData.feeds, ...data.feeds]\r\n          };\r\n        } else {\r\n          mergedData = data;\r\n        }\r\n        \r\n        // Store in localStorage\r\n        localStorage.setItem(storageKey, JSON.stringify(mergedData));\r\n        \r\n        // Also trigger CSV download if the dataset is getting large\r\n        if (mergedData.feeds.length > 1000) {\r\n          const csvContent = convertThingSpeakDataToCSV(mergedData);\r\n          const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\r\n          const link = document.createElement('a');\r\n          const urlObject = URL.createObjectURL(blob);\r\n          \r\n          link.setAttribute('href', urlObject);\r\n          link.setAttribute('download', `patient_data_${channelId}_${new Date().toISOString().slice(0,10)}.csv`);\r\n          link.style.visibility = 'hidden';\r\n          \r\n          document.body.appendChild(link);\r\n          link.click();\r\n          document.body.removeChild(link);\r\n          \r\n          // Reset storage after download\r\n          localStorage.setItem(storageKey, JSON.stringify({\r\n            ...data,\r\n            feeds: data.feeds\r\n          }));\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error in continuous data logging:', error);\r\n    }\r\n  };\r\n  \r\n  // Start logging\r\n  const start = () => {\r\n    if (isLogging) return;\r\n    \r\n    initFromStorage();\r\n    fetchAndStore(); // Immediate first fetch\r\n    \r\n    // Set up interval (convert minutes to milliseconds)\r\n    intervalId = setInterval(fetchAndStore, intervalMinutes * 60 * 1000);\r\n    isLogging = true;\r\n    \r\n    console.log(`Started continuous data logging for channel ${channelId} every ${intervalMinutes} minutes`);\r\n    return true;\r\n  };\r\n  \r\n  // Stop logging\r\n  const stop = () => {\r\n    if (!isLogging) return;\r\n    \r\n    clearInterval(intervalId);\r\n    intervalId = null;\r\n    isLogging = false;\r\n    \r\n    console.log(`Stopped continuous data logging for channel ${channelId}`);\r\n    return true;\r\n  };\r\n  \r\n  // Export data as CSV\r\n  const exportToCSV = (filename = `patient_data_${channelId}.csv`) => {\r\n    const storedData = localStorage.getItem(storageKey);\r\n    if (!storedData) {\r\n      console.warn('No data available to export');\r\n      return false;\r\n    }\r\n    \r\n    try {\r\n      const parsedData = JSON.parse(storedData);\r\n      const csvContent = convertThingSpeakDataToCSV(parsedData);\r\n      \r\n      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\r\n      const link = document.createElement('a');\r\n      const urlObject = URL.createObjectURL(blob);\r\n      \r\n      link.setAttribute('href', urlObject);\r\n      link.setAttribute('download', filename);\r\n      link.style.visibility = 'hidden';\r\n      \r\n      document.body.appendChild(link);\r\n      link.click();\r\n      document.body.removeChild(link);\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error exporting data to CSV:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Return controller object\r\n  return {\r\n    start,\r\n    stop,\r\n    exportToCSV,\r\n    isLogging: () => isLogging,\r\n    getStoredData: () => {\r\n      const storedData = localStorage.getItem(storageKey);\r\n      return storedData ? JSON.parse(storedData) : null;\r\n    },\r\n    clearStoredData: () => {\r\n      localStorage.removeItem(storageKey);\r\n      lastTimestamp = null;\r\n      return true;\r\n    }\r\n  };\r\n};\r\n\r\nexport default {\r\n  fetchLatestData,\r\n  mapThingSpeakToPatientVitals,\r\n  getPatientVitals,\r\n  downloadThingSpeakDataAsCSV,\r\n  startContinuousDataLogging,\r\n  convertThingSpeakDataToCSV\r\n};\r\n\r\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,MAAMA,oBAAoB,GAAG,kBAAkB;AAC/C,MAAMC,QAAQ,GAAG,qCAAqC;;AAEtD;AACA;AACA;AACA,OAAO,MAAMC,eAAe,GAAG,MAAAA,CAAOC,SAAS,EAAEC,MAAM,GAAGJ,oBAAoB,EAAEK,OAAO,GAAG,CAAC,KAAK;EAC9F,IAAI,CAACF,SAAS,EAAE;IACd,MAAM,IAAIG,KAAK,CAAC,wBAAwB,CAAC;EAC3C;EAEA,IAAI;IACF,MAAMC,GAAG,GAAG,GAAGN,QAAQ,IAAIE,SAAS,uBAAuBC,MAAM,YAAYC,OAAO,EAAE;IACtF,MAAMG,QAAQ,GAAG,MAAMC,KAAK,CAACF,GAAG,CAAC;IAEjC,IAAI,CAACC,QAAQ,CAACE,EAAE,EAAE;MAChB,MAAM,IAAIJ,KAAK,CAAC,yBAAyBE,QAAQ,CAACG,MAAM,EAAE,CAAC;IAC7D;IAEA,MAAMC,IAAI,GAAG,MAAMJ,QAAQ,CAACK,IAAI,CAAC,CAAC;IAElC,IAAI,CAACD,IAAI,IAAI,CAACA,IAAI,CAACE,KAAK,IAAIF,IAAI,CAACE,KAAK,CAACC,MAAM,KAAK,CAAC,EAAE;MACnD,MAAM,IAAIT,KAAK,CAAC,mCAAmC,CAAC;IACtD;IAEA,OAAOM,IAAI;EACb,CAAC,CAAC,OAAOI,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,sCAAsC,EAAEA,KAAK,CAAC;IAC5D,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA,OAAO,MAAME,wBAAwB,GAAG,MAAAA,CAAOf,SAAS,EAAEgB,aAAa,EAAEf,MAAM,GAAGJ,oBAAoB,KAAK;EACzG,IAAI,CAACG,SAAS,EAAE;IACd,MAAM,IAAIG,KAAK,CAAC,wBAAwB,CAAC;EAC3C;EAEA,IAAI;IACF;IACA,MAAMc,cAAc,GAAGD,aAAa,GAAG,UAAUA,aAAa,EAAE,GAAG,EAAE;IACrE,MAAMZ,GAAG,GAAG,GAAGN,QAAQ,IAAIE,SAAS,uBAAuBC,MAAM,GAAGgB,cAAc,EAAE;IACpF,MAAMZ,QAAQ,GAAG,MAAMC,KAAK,CAACF,GAAG,CAAC;IAEjC,IAAI,CAACC,QAAQ,CAACE,EAAE,EAAE;MAChB,MAAM,IAAIJ,KAAK,CAAC,yBAAyBE,QAAQ,CAACG,MAAM,EAAE,CAAC;IAC7D;IAEA,MAAMC,IAAI,GAAG,MAAMJ,QAAQ,CAACK,IAAI,CAAC,CAAC;IAClC,OAAOD,IAAI;EACb,CAAC,CAAC,OAAOI,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,wDAAwD,EAAEA,KAAK,CAAC;IAC9E,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMK,WAAW,GAAGA,CAACC,UAAU,EAAEC,IAAI,KAAK;EACxC;EACA,MAAMC,GAAG,GAAG,GAAG,CAAC,CAAC;;EAEjB;EACA,MAAMC,QAAQ,GAAG,GAAG,GAAI,GAAG,GAAGD,GAAI;EAClC,MAAME,SAAS,GAAG,GAAG,GAAI,EAAE,GAAGF,GAAI;EAElC,OAAO;IACLC,QAAQ,EAAEE,IAAI,CAACC,KAAK,CAACH,QAAQ,CAAC;IAC9BC,SAAS,EAAEC,IAAI,CAACC,KAAK,CAACF,SAAS;EACjC,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMG,4BAA4B,GAAIjB,IAAI,IAAK;EACpD,IAAI,CAACA,IAAI,IAAI,CAACA,IAAI,CAACE,KAAK,IAAIF,IAAI,CAACE,KAAK,CAACC,MAAM,KAAK,CAAC,EAAE;IACnD,OAAO,IAAI;EACb;EAEA,MAAMe,WAAW,GAAGlB,IAAI,CAACE,KAAK,CAAC,CAAC,CAAC;;EAEjC;EACA,MAAMiB,WAAW,GAAGC,UAAU,CAACF,WAAW,CAACG,MAAM,CAAC;EAClD,MAAMC,UAAU,GAAGC,QAAQ,CAACL,WAAW,CAACM,MAAM,CAAC;EAC/C,MAAMC,SAAS,GAAGL,UAAU,CAACF,WAAW,CAACQ,MAAM,CAAC;EAChD,MAAMf,IAAI,GAAGS,UAAU,CAACF,WAAW,CAACS,MAAM,CAAC;EAC3C,MAAMC,QAAQ,GAAGR,UAAU,CAACF,WAAW,CAACW,MAAM,CAAC;EAC/C,MAAMC,SAAS,GAAGV,UAAU,CAACF,WAAW,CAACa,MAAM,CAAC;EAChD,MAAMC,MAAM,GAAGZ,UAAU,CAACF,WAAW,CAACe,MAAM,CAAC;EAC7C,MAAMvB,UAAU,GAAGwB,IAAI,CAACC,KAAK,CAACjB,WAAW,CAACkB,MAAM,CAAC;;EAEjD;EACA,MAAMC,EAAE,GAAG5B,WAAW,CAACC,UAAU,EAAEC,IAAI,CAAC;EAExC,OAAO;IACL2B,MAAM,EAAE;MACNnB,WAAW,EAAEoB,KAAK,CAACpB,WAAW,CAAC,GAAG,IAAI,GAAGA,WAAW,CAACqB,OAAO,CAAC,CAAC,CAAC;MAC/DlB,UAAU,EAAEiB,KAAK,CAACjB,UAAU,CAAC,GAAG,CAAC,GAAGA,UAAU;MAC9CG,SAAS,EAAEc,KAAK,CAACd,SAAS,CAAC,GAAG,IAAI,GAAGV,IAAI,CAACC,KAAK,CAACS,SAAS,CAAC;MAC1Dd,IAAI,EAAE4B,KAAK,CAAC5B,IAAI,CAAC,GAAG,IAAI,GAAGI,IAAI,CAACC,KAAK,CAACL,IAAI,CAAC;MAC3CqB,MAAM,EAAEO,KAAK,CAACP,MAAM,CAAC,GAAG,IAAI,GAAGA,MAAM;MACrCtB,UAAU,EAAE+B,KAAK,CAACC,OAAO,CAAChC,UAAU,CAAC,GAAGA,UAAU,GAAG,EAAE;MACvD2B,EAAE,EAAEA;IACN,CAAC;IACDM,QAAQ,EAAE;MACRC,GAAG,EAAEL,KAAK,CAACX,QAAQ,CAAC,GAAG,IAAI,GAAGA,QAAQ;MACtCiB,GAAG,EAAEN,KAAK,CAACT,SAAS,CAAC,GAAG,IAAI,GAAGA,SAAS;MACxCgB,QAAQ,EAAE;IACZ,CAAC;IACD/C,MAAM,EAAE;MACNoB,WAAW,EAAEA,WAAW,GAAG,IAAI,GAAG,UAAU,GAAGA,WAAW,GAAG,IAAI,GAAG,KAAK,GAAG,QAAQ;MACpFM,SAAS,EAAEA,SAAS,GAAG,GAAG,GAAG,UAAU,GAAGA,SAAS,GAAG,EAAE,GAAG,KAAK,GAAG,QAAQ;MAC3Ed,IAAI,EAAEA,IAAI,GAAG,EAAE,GAAG,KAAK,GAAG,QAAQ;MAClC0B,EAAE,EAAEA,EAAE,CAACxB,QAAQ,GAAG,GAAG,IAAIwB,EAAE,CAACvB,SAAS,GAAG,EAAE,GAAG,UAAU,GACnDuB,EAAE,CAACxB,QAAQ,GAAG,EAAE,IAAIwB,EAAE,CAACvB,SAAS,GAAG,EAAE,GAAG,KAAK,GAAG,QAAQ;MAC5DiC,KAAK,EAAEzB,UAAU,KAAK,CAAC,GAAG,QAAQ,GAAGA,UAAU,KAAK,CAAC,GAAG,eAAe,GAAG;IAC5E,CAAC;IACD0B,WAAW,EAAE,IAAIC,IAAI,CAAC/B,WAAW,CAACgC,UAAU,CAAC,CAACC,cAAc,CAAC;EAC/D,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMC,gBAAgB,GAAG,MAAO7D,SAAS,IAAK;EACnD,IAAI,CAACA,SAAS,EAAE;IACd,MAAM,IAAIG,KAAK,CAAC,wBAAwB,CAAC;EAC3C;EAEA,IAAI;IACF,MAAMM,IAAI,GAAG,MAAMV,eAAe,CAACC,SAAS,CAAC;IAC7C,MAAM+C,MAAM,GAAGrB,4BAA4B,CAACjB,IAAI,CAAC;IAEjD,IAAI,CAACsC,MAAM,EAAE;MACX,MAAM,IAAI5C,KAAK,CAAC,yCAAyC,CAAC;IAC5D;IAEA,OAAO4C,MAAM;EACf,CAAC,CAAC,OAAOlC,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;IACrD,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMiD,0BAA0B,GAAIrD,IAAI,IAAK;EAClD,IAAI,CAACA,IAAI,IAAI,CAACA,IAAI,CAACE,KAAK,IAAIF,IAAI,CAACE,KAAK,CAACC,MAAM,KAAK,CAAC,EAAE;IACnD,OAAO,IAAI;EACb;;EAEA;EACA,MAAMmD,OAAO,GAAG,CACd,WAAW,EACX,aAAa,EACb,YAAY,EACZ,WAAW,EACX,MAAM,EACN,UAAU,EACV,WAAW,EACX,QAAQ,EACR,YAAY,EACZ,aAAa,CACd;;EAED;EACA,MAAMC,OAAO,GAAG,EAAE;EAClBA,OAAO,CAACC,IAAI,CAACF,OAAO,CAACG,IAAI,CAAC,GAAG,CAAC,CAAC;;EAE/B;EACAzD,IAAI,CAACE,KAAK,CAACwD,OAAO,CAACC,IAAI,IAAI;IACzB,MAAMxC,WAAW,GAAGC,UAAU,CAACuC,IAAI,CAACtC,MAAM,CAAC;IAC3C,MAAMC,UAAU,GAAGC,QAAQ,CAACoC,IAAI,CAACnC,MAAM,CAAC;IACxC,MAAMC,SAAS,GAAGL,UAAU,CAACuC,IAAI,CAACjC,MAAM,CAAC;IACzC,MAAMf,IAAI,GAAGS,UAAU,CAACuC,IAAI,CAAChC,MAAM,CAAC;IACpC,MAAMC,QAAQ,GAAGR,UAAU,CAACuC,IAAI,CAAC9B,MAAM,CAAC;IACxC,MAAMC,SAAS,GAAGV,UAAU,CAACuC,IAAI,CAAC5B,MAAM,CAAC;IACzC,MAAMC,MAAM,GAAGZ,UAAU,CAACuC,IAAI,CAAC1B,MAAM,CAAC;IACtC,MAAMvB,UAAU,GAAGiD,IAAI,CAACvB,MAAM,GAAGF,IAAI,CAACC,KAAK,CAACwB,IAAI,CAACvB,MAAM,CAAC,GAAG,EAAE;;IAE7D;IACA,MAAMC,EAAE,GAAG5B,WAAW,CAACC,UAAU,EAAEC,IAAI,CAAC;IAExC,MAAMiD,GAAG,GAAG,CACV,IAAIX,IAAI,CAACU,IAAI,CAACT,UAAU,CAAC,CAACW,WAAW,CAAC,CAAC,EACvCtB,KAAK,CAACpB,WAAW,CAAC,GAAG,EAAE,GAAGA,WAAW,CAACqB,OAAO,CAAC,CAAC,CAAC,EAChDD,KAAK,CAACjB,UAAU,CAAC,GAAG,EAAE,GAAGA,UAAU,EACnCiB,KAAK,CAACd,SAAS,CAAC,GAAG,EAAE,GAAGV,IAAI,CAACC,KAAK,CAACS,SAAS,CAAC,EAC7Cc,KAAK,CAAC5B,IAAI,CAAC,GAAG,EAAE,GAAGI,IAAI,CAACC,KAAK,CAACL,IAAI,CAAC,EACnC4B,KAAK,CAACX,QAAQ,CAAC,GAAG,EAAE,GAAGA,QAAQ,EAC/BW,KAAK,CAACT,SAAS,CAAC,GAAG,EAAE,GAAGA,SAAS,EACjCS,KAAK,CAACP,MAAM,CAAC,GAAG,EAAE,GAAGA,MAAM,EAC3BK,EAAE,CAACxB,QAAQ,EACXwB,EAAE,CAACvB,SAAS,CACb;IAEDyC,OAAO,CAACC,IAAI,CAACI,GAAG,CAACH,IAAI,CAAC,GAAG,CAAC,CAAC;EAC7B,CAAC,CAAC;EAEF,OAAOF,OAAO,CAACE,IAAI,CAAC,IAAI,CAAC;AAC3B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMK,2BAA2B,GAAG,MAAAA,CAAOvE,SAAS,EAAEwE,QAAQ,GAAG,kBAAkB,EAAEC,IAAI,GAAG,CAAC,KAAK;EACvG,IAAI,CAACzE,SAAS,EAAE;IACd,MAAM,IAAIG,KAAK,CAAC,wBAAwB,CAAC;EAC3C;EAEA,IAAI;IACF;IACA,MAAMuE,SAAS,GAAG,IAAIhB,IAAI,CAAC,CAAC;IAC5BgB,SAAS,CAACC,OAAO,CAACD,SAAS,CAACE,OAAO,CAAC,CAAC,GAAGH,IAAI,CAAC;;IAE7C;IACA,MAAMrE,GAAG,GAAG,GAAGN,QAAQ,IAAIE,SAAS,uBAAuBH,oBAAoB,UAAU6E,SAAS,CAACJ,WAAW,CAAC,CAAC,EAAE;IAClH,MAAMjE,QAAQ,GAAG,MAAMC,KAAK,CAACF,GAAG,CAAC;IAEjC,IAAI,CAACC,QAAQ,CAACE,EAAE,EAAE;MAChB,MAAM,IAAIJ,KAAK,CAAC,yBAAyBE,QAAQ,CAACG,MAAM,EAAE,CAAC;IAC7D;IAEA,MAAMC,IAAI,GAAG,MAAMJ,QAAQ,CAACK,IAAI,CAAC,CAAC;;IAElC;IACA,MAAMmE,UAAU,GAAGf,0BAA0B,CAACrD,IAAI,CAAC;IAEnD,IAAI,CAACoE,UAAU,EAAE;MACf,MAAM,IAAI1E,KAAK,CAAC,+BAA+B,CAAC;IAClD;;IAEA;IACA,MAAM2E,IAAI,GAAG,IAAIC,IAAI,CAAC,CAACF,UAAU,CAAC,EAAE;MAAEG,IAAI,EAAE;IAA0B,CAAC,CAAC;IACxE,MAAMC,IAAI,GAAGC,QAAQ,CAACC,aAAa,CAAC,GAAG,CAAC;IACxC,MAAMC,SAAS,GAAGC,GAAG,CAACC,eAAe,CAACR,IAAI,CAAC;IAE3CG,IAAI,CAACM,YAAY,CAAC,MAAM,EAAEH,SAAS,CAAC;IACpCH,IAAI,CAACM,YAAY,CAAC,UAAU,EAAEf,QAAQ,CAAC;IACvCS,IAAI,CAACO,KAAK,CAACC,UAAU,GAAG,QAAQ;IAEhCP,QAAQ,CAACQ,IAAI,CAACC,WAAW,CAACV,IAAI,CAAC;IAC/BA,IAAI,CAACW,KAAK,CAAC,CAAC;IACZV,QAAQ,CAACQ,IAAI,CAACG,WAAW,CAACZ,IAAI,CAAC;IAE/B,OAAO,IAAI;EACb,CAAC,CAAC,OAAOpE,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,2CAA2C,EAAEA,KAAK,CAAC;IACjE,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMiF,0BAA0B,GAAGA,CAAC9F,SAAS,EAAE+F,eAAe,GAAG,CAAC,KAAK;EAC5E,IAAI,CAAC/F,SAAS,EAAE;IACd,MAAM,IAAIG,KAAK,CAAC,wBAAwB,CAAC;EAC3C;EAEA,IAAI6F,UAAU,GAAG,IAAI;EACrB,IAAIC,SAAS,GAAG,KAAK;EACrB,IAAIjF,aAAa,GAAG,IAAI;EACxB,MAAMkF,UAAU,GAAG,mBAAmBlG,SAAS,EAAE;;EAEjD;EACA,MAAMmG,eAAe,GAAGA,CAAA,KAAM;IAC5B,MAAMC,UAAU,GAAGC,YAAY,CAACC,OAAO,CAACJ,UAAU,CAAC;IACnD,IAAIE,UAAU,EAAE;MACd,IAAI;QACF,MAAMG,UAAU,GAAG5D,IAAI,CAACC,KAAK,CAACwD,UAAU,CAAC;QACzC,IAAIG,UAAU,CAAC5F,KAAK,IAAI4F,UAAU,CAAC5F,KAAK,CAACC,MAAM,GAAG,CAAC,EAAE;UACnD;UACA,MAAMe,WAAW,GAAG4E,UAAU,CAAC5F,KAAK,CAAC4F,UAAU,CAAC5F,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC;UACjEI,aAAa,GAAG,IAAI0C,IAAI,CAAC/B,WAAW,CAACgC,UAAU,CAAC,CAACW,WAAW,CAAC,CAAC;QAChE;MACF,CAAC,CAAC,OAAOzD,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;QAClDwF,YAAY,CAACG,UAAU,CAACN,UAAU,CAAC;MACrC;IACF;EACF,CAAC;;EAED;EACA,MAAMO,aAAa,GAAG,MAAAA,CAAA,KAAY;IAChC,IAAI;MACF,MAAMhG,IAAI,GAAG,MAAMM,wBAAwB,CAACf,SAAS,EAAEgB,aAAa,CAAC;MAErE,IAAIP,IAAI,IAAIA,IAAI,CAACE,KAAK,IAAIF,IAAI,CAACE,KAAK,CAACC,MAAM,GAAG,CAAC,EAAE;QAC/C;QACA,MAAMe,WAAW,GAAGlB,IAAI,CAACE,KAAK,CAACF,IAAI,CAACE,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC;QACrDI,aAAa,GAAG,IAAI0C,IAAI,CAAC/B,WAAW,CAACgC,UAAU,CAAC,CAACW,WAAW,CAAC,CAAC;;QAE9D;QACA,MAAM8B,UAAU,GAAGC,YAAY,CAACC,OAAO,CAACJ,UAAU,CAAC;QACnD,IAAIQ,UAAU;QAEd,IAAIN,UAAU,EAAE;UACd,MAAMG,UAAU,GAAG5D,IAAI,CAACC,KAAK,CAACwD,UAAU,CAAC;UACzCM,UAAU,GAAG;YACX,GAAGjG,IAAI;YACPE,KAAK,EAAE,CAAC,GAAG4F,UAAU,CAAC5F,KAAK,EAAE,GAAGF,IAAI,CAACE,KAAK;UAC5C,CAAC;QACH,CAAC,MAAM;UACL+F,UAAU,GAAGjG,IAAI;QACnB;;QAEA;QACA4F,YAAY,CAACM,OAAO,CAACT,UAAU,EAAEvD,IAAI,CAACiE,SAAS,CAACF,UAAU,CAAC,CAAC;;QAE5D;QACA,IAAIA,UAAU,CAAC/F,KAAK,CAACC,MAAM,GAAG,IAAI,EAAE;UAClC,MAAMiE,UAAU,GAAGf,0BAA0B,CAAC4C,UAAU,CAAC;UACzD,MAAM5B,IAAI,GAAG,IAAIC,IAAI,CAAC,CAACF,UAAU,CAAC,EAAE;YAAEG,IAAI,EAAE;UAA0B,CAAC,CAAC;UACxE,MAAMC,IAAI,GAAGC,QAAQ,CAACC,aAAa,CAAC,GAAG,CAAC;UACxC,MAAMC,SAAS,GAAGC,GAAG,CAACC,eAAe,CAACR,IAAI,CAAC;UAE3CG,IAAI,CAACM,YAAY,CAAC,MAAM,EAAEH,SAAS,CAAC;UACpCH,IAAI,CAACM,YAAY,CAAC,UAAU,EAAE,gBAAgBvF,SAAS,IAAI,IAAI0D,IAAI,CAAC,CAAC,CAACY,WAAW,CAAC,CAAC,CAACuC,KAAK,CAAC,CAAC,EAAC,EAAE,CAAC,MAAM,CAAC;UACtG5B,IAAI,CAACO,KAAK,CAACC,UAAU,GAAG,QAAQ;UAEhCP,QAAQ,CAACQ,IAAI,CAACC,WAAW,CAACV,IAAI,CAAC;UAC/BA,IAAI,CAACW,KAAK,CAAC,CAAC;UACZV,QAAQ,CAACQ,IAAI,CAACG,WAAW,CAACZ,IAAI,CAAC;;UAE/B;UACAoB,YAAY,CAACM,OAAO,CAACT,UAAU,EAAEvD,IAAI,CAACiE,SAAS,CAAC;YAC9C,GAAGnG,IAAI;YACPE,KAAK,EAAEF,IAAI,CAACE;UACd,CAAC,CAAC,CAAC;QACL;MACF;IACF,CAAC,CAAC,OAAOE,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;IAC3D;EACF,CAAC;;EAED;EACA,MAAMiG,KAAK,GAAGA,CAAA,KAAM;IAClB,IAAIb,SAAS,EAAE;IAEfE,eAAe,CAAC,CAAC;IACjBM,aAAa,CAAC,CAAC,CAAC,CAAC;;IAEjB;IACAT,UAAU,GAAGe,WAAW,CAACN,aAAa,EAAEV,eAAe,GAAG,EAAE,GAAG,IAAI,CAAC;IACpEE,SAAS,GAAG,IAAI;IAEhBnF,OAAO,CAACkG,GAAG,CAAC,+CAA+ChH,SAAS,UAAU+F,eAAe,UAAU,CAAC;IACxG,OAAO,IAAI;EACb,CAAC;;EAED;EACA,MAAMkB,IAAI,GAAGA,CAAA,KAAM;IACjB,IAAI,CAAChB,SAAS,EAAE;IAEhBiB,aAAa,CAAClB,UAAU,CAAC;IACzBA,UAAU,GAAG,IAAI;IACjBC,SAAS,GAAG,KAAK;IAEjBnF,OAAO,CAACkG,GAAG,CAAC,+CAA+ChH,SAAS,EAAE,CAAC;IACvE,OAAO,IAAI;EACb,CAAC;;EAED;EACA,MAAMmH,WAAW,GAAGA,CAAC3C,QAAQ,GAAG,gBAAgBxE,SAAS,MAAM,KAAK;IAClE,MAAMoG,UAAU,GAAGC,YAAY,CAACC,OAAO,CAACJ,UAAU,CAAC;IACnD,IAAI,CAACE,UAAU,EAAE;MACftF,OAAO,CAACsG,IAAI,CAAC,6BAA6B,CAAC;MAC3C,OAAO,KAAK;IACd;IAEA,IAAI;MACF,MAAMb,UAAU,GAAG5D,IAAI,CAACC,KAAK,CAACwD,UAAU,CAAC;MACzC,MAAMvB,UAAU,GAAGf,0BAA0B,CAACyC,UAAU,CAAC;MAEzD,MAAMzB,IAAI,GAAG,IAAIC,IAAI,CAAC,CAACF,UAAU,CAAC,EAAE;QAAEG,IAAI,EAAE;MAA0B,CAAC,CAAC;MACxE,MAAMC,IAAI,GAAGC,QAAQ,CAACC,aAAa,CAAC,GAAG,CAAC;MACxC,MAAMC,SAAS,GAAGC,GAAG,CAACC,eAAe,CAACR,IAAI,CAAC;MAE3CG,IAAI,CAACM,YAAY,CAAC,MAAM,EAAEH,SAAS,CAAC;MACpCH,IAAI,CAACM,YAAY,CAAC,UAAU,EAAEf,QAAQ,CAAC;MACvCS,IAAI,CAACO,KAAK,CAACC,UAAU,GAAG,QAAQ;MAEhCP,QAAQ,CAACQ,IAAI,CAACC,WAAW,CAACV,IAAI,CAAC;MAC/BA,IAAI,CAACW,KAAK,CAAC,CAAC;MACZV,QAAQ,CAACQ,IAAI,CAACG,WAAW,CAACZ,IAAI,CAAC;MAE/B,OAAO,IAAI;IACb,CAAC,CAAC,OAAOpE,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;MACpD,OAAO,KAAK;IACd;EACF,CAAC;;EAED;EACA,OAAO;IACLiG,KAAK;IACLG,IAAI;IACJE,WAAW;IACXlB,SAAS,EAAEA,CAAA,KAAMA,SAAS;IAC1BoB,aAAa,EAAEA,CAAA,KAAM;MACnB,MAAMjB,UAAU,GAAGC,YAAY,CAACC,OAAO,CAACJ,UAAU,CAAC;MACnD,OAAOE,UAAU,GAAGzD,IAAI,CAACC,KAAK,CAACwD,UAAU,CAAC,GAAG,IAAI;IACnD,CAAC;IACDkB,eAAe,EAAEA,CAAA,KAAM;MACrBjB,YAAY,CAACG,UAAU,CAACN,UAAU,CAAC;MACnClF,aAAa,GAAG,IAAI;MACpB,OAAO,IAAI;IACb;EACF,CAAC;AACH,CAAC;AAED,eAAe;EACbjB,eAAe;EACf2B,4BAA4B;EAC5BmC,gBAAgB;EAChBU,2BAA2B;EAC3BuB,0BAA0B;EAC1BhC;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}