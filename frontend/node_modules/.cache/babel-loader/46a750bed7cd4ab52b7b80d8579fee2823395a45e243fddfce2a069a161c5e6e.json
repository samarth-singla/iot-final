{"ast":null,"code":"/**\n * ThingSpeak API Service\n * Handles fetching data from ThingSpeak channels\n */\n\n// Default API key provided in your requirements\nconst DEFAULT_READ_API_KEY = \"MWFBV98HOZOHTHY4\";\n\n/**\n * Fetches the latest data from a ThingSpeak channel\n * \n * @param {string} channelId - The ThingSpeak channel ID\n * @param {string} apiKey - The read API key (optional, will use default if not provided)\n * @param {number} results - Number of results to return (default: 1)\n * @returns {Promise} - Promise that resolves to the ThingSpeak data\n */\nexport const fetchLatestData = async (channelId, apiKey = DEFAULT_READ_API_KEY, results = 1) => {\n  try {\n    const url = `https://api.thingspeak.com/channels/${channelId}/feeds.json?api_key=${apiKey}&results=${results}`;\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`ThingSpeak API error: ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Error fetching data from ThingSpeak:', error);\n    throw error;\n  }\n};\n\n/**\n * Maps the raw ThingSpeak data to patient vital signs\n * \n * @param {Object} data - Raw ThingSpeak response data\n * @returns {Object} - Formatted patient vitals\n */\nexport const mapThingSpeakToPatientVitals = data => {\n  if (!data || !data.feeds || data.feeds.length === 0) {\n    return null;\n  }\n  const latestEntry = data.feeds[0];\n  return {\n    vitals: {\n      bloodPressure: `${latestEntry.field4 || \"--\"}/${latestEntry.field5 || \"--\"}`,\n      pulse: latestEntry.field1 || \"--\",\n      temperature: latestEntry.field2 || \"--\",\n      spo2: latestEntry.field3 || \"--\",\n      respiration: latestEntry.field8 || \"--\"\n    },\n    location: {\n      lat: parseFloat(latestEntry.field6) || 28.6139,\n      lng: parseFloat(latestEntry.field7) || 77.2090,\n      accuracy: 15\n    },\n    ecgStatus: parseInt(latestEntry.field1) > 100 ? \"Elevated\" : \"Normal\",\n    lastUpdated: new Date(latestEntry.created_at).toLocaleString()\n  };\n};\n\n/**\n * Fetches data from ThingSpeak and maps it to patient vitals format\n * \n * @param {string} channelId - The ThingSpeak channel ID\n * @returns {Promise} - Promise that resolves to formatted patient vitals\n */\nexport const getPatientVitals = async channelId => {\n  try {\n    const data = await fetchLatestData(channelId);\n    return mapThingSpeakToPatientVitals(data);\n  } catch (error) {\n    console.error('Error getting patient vitals:', error);\n    throw error;\n  }\n};\nexport default {\n  fetchLatestData,\n  mapThingSpeakToPatientVitals,\n  getPatientVitals\n};","map":{"version":3,"names":["DEFAULT_READ_API_KEY","fetchLatestData","channelId","apiKey","results","url","response","fetch","ok","Error","status","json","error","console","mapThingSpeakToPatientVitals","data","feeds","length","latestEntry","vitals","bloodPressure","field4","field5","pulse","field1","temperature","field2","spo2","field3","respiration","field8","location","lat","parseFloat","field6","lng","field7","accuracy","ecgStatus","parseInt","lastUpdated","Date","created_at","toLocaleString","getPatientVitals"],"sources":["/home/ujjwal-gupta/Desktop/temp/IoT-Main/frontend/src/services/ThingSpeakService.js"],"sourcesContent":["\n/**\n * ThingSpeak API Service\n * Handles fetching data from ThingSpeak channels\n */\n\n// Default API key provided in your requirements\nconst DEFAULT_READ_API_KEY = \"MWFBV98HOZOHTHY4\";\n\n/**\n * Fetches the latest data from a ThingSpeak channel\n * \n * @param {string} channelId - The ThingSpeak channel ID\n * @param {string} apiKey - The read API key (optional, will use default if not provided)\n * @param {number} results - Number of results to return (default: 1)\n * @returns {Promise} - Promise that resolves to the ThingSpeak data\n */\nexport const fetchLatestData = async (channelId, apiKey = DEFAULT_READ_API_KEY, results = 1) => {\n  try {\n    const url = `https://api.thingspeak.com/channels/${channelId}/feeds.json?api_key=${apiKey}&results=${results}`;\n    \n    const response = await fetch(url);\n    \n    if (!response.ok) {\n      throw new Error(`ThingSpeak API error: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('Error fetching data from ThingSpeak:', error);\n    throw error;\n  }\n};\n\n/**\n * Maps the raw ThingSpeak data to patient vital signs\n * \n * @param {Object} data - Raw ThingSpeak response data\n * @returns {Object} - Formatted patient vitals\n */\nexport const mapThingSpeakToPatientVitals = (data) => {\n  if (!data || !data.feeds || data.feeds.length === 0) {\n    return null;\n  }\n  \n  const latestEntry = data.feeds[0];\n  \n  return {\n    vitals: {\n      bloodPressure: `${latestEntry.field4 || \"--\"}/${latestEntry.field5 || \"--\"}`,\n      pulse: latestEntry.field1 || \"--\",\n      temperature: latestEntry.field2 || \"--\",\n      spo2: latestEntry.field3 || \"--\",\n      respiration: latestEntry.field8 || \"--\"\n    },\n    location: {\n      lat: parseFloat(latestEntry.field6) || 28.6139,\n      lng: parseFloat(latestEntry.field7) || 77.2090,\n      accuracy: 15\n    },\n    ecgStatus: parseInt(latestEntry.field1) > 100 ? \"Elevated\" : \"Normal\",\n    lastUpdated: new Date(latestEntry.created_at).toLocaleString()\n  };\n};\n\n/**\n * Fetches data from ThingSpeak and maps it to patient vitals format\n * \n * @param {string} channelId - The ThingSpeak channel ID\n * @returns {Promise} - Promise that resolves to formatted patient vitals\n */\nexport const getPatientVitals = async (channelId) => {\n  try {\n    const data = await fetchLatestData(channelId);\n    return mapThingSpeakToPatientVitals(data);\n  } catch (error) {\n    console.error('Error getting patient vitals:', error);\n    throw error;\n  }\n};\n\nexport default {\n  fetchLatestData,\n  mapThingSpeakToPatientVitals,\n  getPatientVitals\n};\n\n"],"mappings":"AACA;AACA;AACA;AACA;;AAEA;AACA,MAAMA,oBAAoB,GAAG,kBAAkB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,eAAe,GAAG,MAAAA,CAAOC,SAAS,EAAEC,MAAM,GAAGH,oBAAoB,EAAEI,OAAO,GAAG,CAAC,KAAK;EAC9F,IAAI;IACF,MAAMC,GAAG,GAAG,uCAAuCH,SAAS,uBAAuBC,MAAM,YAAYC,OAAO,EAAE;IAE9G,MAAME,QAAQ,GAAG,MAAMC,KAAK,CAACF,GAAG,CAAC;IAEjC,IAAI,CAACC,QAAQ,CAACE,EAAE,EAAE;MAChB,MAAM,IAAIC,KAAK,CAAC,yBAAyBH,QAAQ,CAACI,MAAM,EAAE,CAAC;IAC7D;IAEA,OAAO,MAAMJ,QAAQ,CAACK,IAAI,CAAC,CAAC;EAC9B,CAAC,CAAC,OAAOC,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,sCAAsC,EAAEA,KAAK,CAAC;IAC5D,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,4BAA4B,GAAIC,IAAI,IAAK;EACpD,IAAI,CAACA,IAAI,IAAI,CAACA,IAAI,CAACC,KAAK,IAAID,IAAI,CAACC,KAAK,CAACC,MAAM,KAAK,CAAC,EAAE;IACnD,OAAO,IAAI;EACb;EAEA,MAAMC,WAAW,GAAGH,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC;EAEjC,OAAO;IACLG,MAAM,EAAE;MACNC,aAAa,EAAE,GAAGF,WAAW,CAACG,MAAM,IAAI,IAAI,IAAIH,WAAW,CAACI,MAAM,IAAI,IAAI,EAAE;MAC5EC,KAAK,EAAEL,WAAW,CAACM,MAAM,IAAI,IAAI;MACjCC,WAAW,EAAEP,WAAW,CAACQ,MAAM,IAAI,IAAI;MACvCC,IAAI,EAAET,WAAW,CAACU,MAAM,IAAI,IAAI;MAChCC,WAAW,EAAEX,WAAW,CAACY,MAAM,IAAI;IACrC,CAAC;IACDC,QAAQ,EAAE;MACRC,GAAG,EAAEC,UAAU,CAACf,WAAW,CAACgB,MAAM,CAAC,IAAI,OAAO;MAC9CC,GAAG,EAAEF,UAAU,CAACf,WAAW,CAACkB,MAAM,CAAC,IAAI,OAAO;MAC9CC,QAAQ,EAAE;IACZ,CAAC;IACDC,SAAS,EAAEC,QAAQ,CAACrB,WAAW,CAACM,MAAM,CAAC,GAAG,GAAG,GAAG,UAAU,GAAG,QAAQ;IACrEgB,WAAW,EAAE,IAAIC,IAAI,CAACvB,WAAW,CAACwB,UAAU,CAAC,CAACC,cAAc,CAAC;EAC/D,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,gBAAgB,GAAG,MAAO1C,SAAS,IAAK;EACnD,IAAI;IACF,MAAMa,IAAI,GAAG,MAAMd,eAAe,CAACC,SAAS,CAAC;IAC7C,OAAOY,4BAA4B,CAACC,IAAI,CAAC;EAC3C,CAAC,CAAC,OAAOH,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;IACrD,MAAMA,KAAK;EACb;AACF,CAAC;AAED,eAAe;EACbX,eAAe;EACfa,4BAA4B;EAC5B8B;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}